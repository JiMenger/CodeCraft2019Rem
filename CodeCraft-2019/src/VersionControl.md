# Version Control

## 初赛
### V1.0 分组法原版

### V2.0 去除G版

### V3.0 精简版

### V4.0 优先对列版
- V4.1 将出发对列改成了heapq方法
- V4.2 将is_conflicted方法更改成了复赛版本，修改了对应Road类的cars_to_go_queue对列

### V6.0 使用了优先对列
- V6.1 优化第三步发车装载的逻辑，对非预设车的发车做了delay控制，可以避免堵塞
- V6.2 更改车库内最短距离问题，使用了新的列表存储，并且降低了PriorCar的权利，因为地图2很容易死
- V6.3 去除了装载模块，原因是装载模块遍历时耗时很长，尤其是频率堆积的时候；修复了第一步骤的调度车道，本来放在for循环里的，浪费了时间
- V6.4 优化了上路的道路尾部判断，使用一个标定锚即可；并且对后续上路的车辆进行了速度惩罚，调慢了一点点优先车辆的速度
- V6.5 修复：第二调度阶段，一旦有车通过路口，即全图上车（之前是局部扫描）；在第二调度阶段，因为改为全图上车后，就扫描全部道路（之前是第一调度后有车移动后的道路）


## 复赛（1）CodeCraftRem
- V5.0 自5.0版本以来开始使用全局动态路径算法
- V6.0 正式解决小车delay引起的实际判别器调度顺序不一致问题，与动态路径产生调度错乱问题，原则上已经完全模拟服务器的判别器
- V7.0 由于V6.0的一些意外，以及服务器运行结果总是不一致，继续调节各种参数与逻辑。。。

## 复赛（2）SpiderMenCome
- V1.0 **完全修复bug，开始拟合之路！**
- V1.1 完善了1.0，并调试出4,0.16的较好参数

# Thoughts
- 不能使用道路尾部空位的位置变化作为判断是否激活车库发车的依据，例子：
	+ A道路长度6，在车道0上有1-5五辆小车连在一起，尾部0位置空缺，因为5号小车在道路头部，因此第一步调度时它处于等待状态，这会导致后面的小车均处于等待状态，这样的话车库里一辆速度为2的小车就无法进入该道路，因为被阻挡的1号小车处于等待状态
	+ 经过第二步调度后5号小车因为下一条道路全部占满堵死从而无法穿过路口，并标记成了结束状态，这会导致1-4号车均标记为结束状态，此时空位（0,0）并无发生改变，但车库里的车却能上路了
- 每次小车越过路口后，要重新生成优先级队列，因为如果普通车辆后面是优先车辆，普通车走了后，优先级就会发生变化
- 凡是加入了车库的车，都要参与车库发车的排序，而且必须是在第一阶段调度之前就要装载好优先车，第三阶段调度之前装载好普通车，其他时间不能装载小车
- 对优先小车组和普通小车组使用不同的路径，按照出发时间、速度、到达时间、ID排序，不断加载固定数目的小车，让他们参与发车
- 通过时间和道路检测
- **动态规划路径的时候要注意更改剩余路径的问题**
	+ 假设一辆车21499在第5时间片要从道路5911(77,41)驶往6448(41,78)，因为下一段距离不够本应该行驶到路的尽头使整条路后面的车辆以及车库里的车得到调度；
	+ 但是因为转向问题冲突从而停止调度，继被冲突的车驶过路口后它才开始调度，但是整个路面的情况已经发生了改变
	+ 此时，你又开始进行了路径的重新规划，并给21499车重新设计了一条直行的路，并且在下一时间片6的时候通过了路口，此路径保存了下来
	+ 官方判别器在运行时，无法侦查到此种改变，因此21499在第5时间片就直接驶过了它在未来要直行通过的路口，因此整个判别过程与程序运行时开始大相径庭
	+ 一个较好的系统，原本可能没有的死锁，开始意外发生